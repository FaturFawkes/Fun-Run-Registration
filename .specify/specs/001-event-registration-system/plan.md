# Implementation Plan: Event Registration System

**Branch**: `001-event-registration-system` | **Date**: 2025-12-31 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `.specify/specs/001-event-registration-system/spec.md`

## Summary

Build an MVP event registration system for Tau-Tau Run Fun Run 5K consisting of:
1. Public landing page for participant registration
2. Admin dashboard for payment status management
3. Golang REST API backend with PostgreSQL database
4. Automatic SMTP email confirmation on payment

**Technical Approach**: Monolith architecture with clear API contracts, state-driven workflow (registration_status, payment_status), and frontend built with Bolt AI consuming REST API.

## Technical Context

**Language/Version**: 
- Backend: Go 1.21+
- Frontend: Next.js 14+ (React, TypeScript)
- Database: PostgreSQL 15+

**Primary Dependencies**: 
- Backend: `github.com/gin-gonic/gin` (HTTP framework), `github.com/lib/pq` (PostgreSQL driver), `golang.org/x/crypto/bcrypt` (password hashing), `net/smtp` (email sending), `github.com/joho/godotenv` (configuration)
- Frontend: Next.js, React, TailwindCSS, Axios/Fetch API

**Storage**: PostgreSQL (relational database with strict schema)

**Testing**: 
- Backend: `go test` with table-driven tests
- Frontend: Manual testing (MVP - no automated tests initially)
- Integration: Manual end-to-end flow testing

**Target Platform**: 
- Backend: Linux server (containerizable)
- Frontend: Web browsers (Chrome, Firefox, Safari latest versions)

**Project Type**: Web application (frontend + backend)

**Performance Goals**: 
- API response time: <200ms p95 for all endpoints
- Email delivery: <5 seconds after payment status update
- Support: 100 concurrent users minimum
- Database: Handle 1000+ participants

**Constraints**: 
- Single admin user (no multi-user auth)
- SMTP email only (no SendGrid, AWS SES, etc.)
- No external state management (Redux, MobX) in frontend
- No WebSockets or real-time features
- Monolith deployment (single backend service)

**Scale/Scope**: 
- Expected: 100-500 participants for initial event
- Admin users: 1
- API endpoints: ~8 endpoints
- Frontend pages: 2 (landing page, admin dashboard)

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

✅ **MVP-First, Event-Driven Design**
- Feature set strictly limited to registration and payment management
- No analytics, reporting, or speculative features
- Direct support for event day operations

✅ **Backend as the Source of Truth**
- All business logic in Golang backend
- PostgreSQL stores all state
- Frontend is pure presentation layer

✅ **State-Driven Workflow (NON-NEGOTIABLE)**
- Explicit states: `registration_status` (PENDING/CONFIRMED), `payment_status` (UNPAID/PAID)
- Email trigger only on `UNPAID → PAID` transition
- No implicit behavior

✅ **Simple Admin, Secure by Default**
- Single admin role
- Email + password authentication
- Bcrypt password hashing (12 rounds minimum)
- Admin routes isolated from public routes

✅ **Design Consistency & Color Discipline**
- TailwindCSS for consistent styling
- Flat, modern, poster-like design
- Color palette to be defined (project constitution referenced)

✅ **Technical Constraints Compliance**
- Golang REST API ✓
- PostgreSQL ✓
- Next.js (Bolt AI) ✓
- SMTP email ✓
- Monolith architecture ✓
- No NoSQL, no message queues, no external email APIs ✓

**Violations**: None. Plan fully complies with constitution.

## Project Structure

### Documentation (this feature)

```text
.specify/specs/001-event-registration-system/
├── plan.md              # This file
├── research.md          # Technology and library research
├── data-model.md        # Database schema and entity definitions
├── quickstart.md        # Development setup and running guide
├── contracts/           # API endpoint contracts
│   ├── public-api.md
│   └── admin-api.md
└── tasks.md             # Generated by /speckit.tasks command
```

### Source Code (repository root)

```text
backend/
├── cmd/
│   └── server/
│       └── main.go              # Application entrypoint
├── internal/
│   ├── models/
│   │   ├── participant.go       # Participant entity
│   │   └── admin.go             # Admin entity
│   ├── database/
│   │   ├── db.go                # Database connection
│   │   └── migrations/          # SQL migration files
│   │       └── 001_init.sql
│   ├── handlers/
│   │   ├── participant.go       # Public registration handlers
│   │   └── admin.go             # Admin dashboard handlers
│   ├── services/
│   │   ├── email.go             # SMTP email service
│   │   └── auth.go              # Authentication service
│   └── middleware/
│       └── auth.go              # JWT/session middleware
├── config/
│   └── config.go                # Configuration management
├── go.mod
├── go.sum
├── .env.example
└── README.md

frontend/
├── src/
│   ├── app/
│   │   ├── page.tsx             # Public landing page
│   │   ├── admin/
│   │   │   ├── login/
│   │   │   │   └── page.tsx     # Admin login
│   │   │   └── dashboard/
│   │   │       └── page.tsx     # Admin dashboard
│   │   └── layout.tsx
│   ├── components/
│   │   ├── RegistrationForm.tsx
│   │   ├── ParticipantList.tsx
│   │   └── PaymentStatusToggle.tsx
│   ├── services/
│   │   └── api.ts               # API client (axios/fetch)
│   └── types/
│       └── index.ts             # TypeScript types
├── public/
│   └── assets/                  # Images, logos
├── package.json
├── tsconfig.json
├── tailwind.config.ts
├── next.config.js
└── .env.local.example

database/
└── migrations/
    └── 001_init.sql             # Initial schema

docs/
├── API.md                       # API documentation
└── DEPLOYMENT.md                # Deployment guide

docker-compose.yml               # Local development setup
.gitignore
README.md
```

**Structure Decision**: Web application structure selected because the project requires both a public-facing frontend (Next.js) and a backend API (Golang). The backend and frontend are separate projects but part of the same repository (monorepo). Database migrations are version-controlled separately. Docker Compose provides local development environment parity.

## Complexity Tracking

**No violations** - All design decisions align with constitution principles. No additional complexity introduced beyond MVP requirements.

---

## Phase 0: Research

### Technology Stack Validation

**Backend Framework**: Gin (github.com/gin-gonic/gin)
- Lightweight, fast HTTP framework
- Excellent for REST APIs
- Built-in middleware support
- Good documentation

**Database Driver**: lib/pq (github.com/lib/pq)
- Pure Go PostgreSQL driver
- Standard library compatible
- Stable and widely used

**Password Hashing**: bcrypt (golang.org/x/crypto/bcrypt)
- Industry standard for password hashing
- Adjustable cost factor
- Built-in salt generation

**SMTP Email**: net/smtp (Go standard library)
- No external dependencies
- Direct SMTP protocol support
- Configuration via environment variables

**Frontend Framework**: Next.js 14+
- Server-side rendering support
- File-based routing
- TypeScript support
- TailwindCSS integration

**API Communication**: Fetch API / Axios
- Native browser support (Fetch)
- Or Axios for better error handling and interceptors

### Key Technical Decisions

1. **Authentication**: JWT tokens stored in HTTP-only cookies
   - Secure against XSS
   - Stateless backend
   - Simple logout implementation

2. **Database Migrations**: SQL files + manual execution
   - Version controlled
   - No ORM complexity
   - Direct SQL for transparency

3. **Email Resilience**: Async email sending with goroutines
   - Payment update succeeds even if email fails
   - Email errors logged but don't block API response
   - Retry logic optional (not in MVP)

4. **Form Validation**: Backend validation only
   - Frontend provides UX hints
   - Backend is source of truth for validation
   - Prevents bypass via API calls

5. **Admin Session**: JWT with 24-hour expiration
   - Simple refresh mechanism
   - Logged out on token expiry
   - No multi-device session management

---

## Phase 1: Design

### Data Model

See [data-model.md](./data-model.md) for detailed schema.

**Core Tables**:

1. **participants**
   - id (UUID, primary key)
   - name (VARCHAR NOT NULL)
   - email (VARCHAR UNIQUE NOT NULL)
   - phone (VARCHAR NOT NULL)
   - instagram_handle (VARCHAR NULL)
   - address (TEXT NOT NULL)
   - registration_status (ENUM: PENDING, CONFIRMED)
   - payment_status (ENUM: UNPAID, PAID)
   - created_at (TIMESTAMP)
   - updated_at (TIMESTAMP)

2. **admins**
   - id (UUID, primary key)
   - email (VARCHAR UNIQUE NOT NULL)
   - password_hash (VARCHAR NOT NULL)
   - created_at (TIMESTAMP)

3. **email_logs** (optional for MVP, recommended for debugging)
   - id (UUID, primary key)
   - participant_id (UUID, foreign key)
   - sent_at (TIMESTAMP)
   - status (ENUM: SUCCESS, FAILED)
   - error_message (TEXT NULL)

### API Contracts

See [contracts/](./contracts/) for detailed endpoint specifications.

**Public API** (`/api/v1/public`):

- `POST /register` - Register new participant
  - Request: `{ name, email, phone, instagram_handle, address }`
  - Response: `{ id, message }`
  - Errors: 400 (validation), 409 (duplicate email)

**Admin API** (`/api/v1/admin`):

- `POST /login` - Admin authentication
  - Request: `{ email, password }`
  - Response: `{ token }` (JWT)
  - Errors: 401 (invalid credentials)

- `GET /participants` - List all participants
  - Headers: `Authorization: Bearer <token>`
  - Response: `{ participants: [...] }`
  - Errors: 401 (unauthorized)

- `PATCH /participants/:id/payment` - Update payment status
  - Headers: `Authorization: Bearer <token>`
  - Request: `{ payment_status: "PAID" }`
  - Response: `{ id, payment_status, message }`
  - Errors: 401 (unauthorized), 404 (not found), 400 (invalid status)
  - Side effect: Triggers email if UNPAID→PAID

### Email Template

**Subject**: "Tau-Tau Run 5K - Registration Confirmed ✓"

**Body**:
```
Hi {name},

Your registration for Tau-Tau Run 5K has been confirmed!

Registration Details:
- Name: {name}
- Email: {email}
- Phone: {phone}
- Instagram: {instagram_handle}

Your payment has been received and processed.

Event Details:
- Event: Tau-Tau Run Fun Run 5K
- Date: [TBD - configure via env]
- Location: [TBD - configure via env]

We look forward to seeing you at the event!

Best regards,
Tau-Tau Run Team

---
This is an automated email. Please do not reply.
```

### Quickstart

See [quickstart.md](./quickstart.md) for detailed setup.

**Quick Setup**:

```bash
# Clone repository
git clone <repo-url>
cd tau-tau-run

# Backend setup
cd backend
cp .env.example .env
# Edit .env with database and SMTP credentials
go mod download
go run cmd/server/main.go

# Frontend setup (separate terminal)
cd frontend
cp .env.local.example .env.local
# Edit .env.local with API URL
npm install
npm run dev

# Database setup
# Run migration: database/migrations/001_init.sql
# Create initial admin user (manual SQL or seed script)
```

---

## Phase 2: Implementation Tasks

Tasks will be generated using `/speckit.tasks` command and stored in `tasks.md`.

**High-Level Task Breakdown**:

1. **Database Setup**
   - Create PostgreSQL database
   - Run initial migration
   - Create admin seed script

2. **Backend Core**
   - Setup Gin server
   - Database connection pooling
   - Configuration management (env vars)

3. **Backend Models**
   - Participant model
   - Admin model
   - Database queries

4. **Backend Services**
   - Email service (SMTP)
   - Auth service (JWT + bcrypt)

5. **Backend Handlers**
   - Public registration endpoint
   - Admin login endpoint
   - Admin participant list endpoint
   - Admin payment update endpoint

6. **Backend Middleware**
   - JWT authentication middleware
   - CORS middleware
   - Error handling middleware

7. **Frontend Setup**
   - Next.js project initialization
   - TailwindCSS configuration
   - API client setup

8. **Frontend Components**
   - Registration form component
   - Participant list component
   - Payment status toggle component

9. **Frontend Pages**
   - Public landing page
   - Admin login page
   - Admin dashboard page

10. **Integration & Testing**
    - End-to-end registration flow
    - Admin login and payment update flow
    - Email delivery testing
    - Error handling testing

11. **Documentation**
    - API documentation
    - Deployment guide
    - Environment variable documentation

12. **Deployment Preparation**
    - Docker/docker-compose setup
    - Production environment checklist
    - SMTP configuration validation

---

## Risk Assessment

| Risk | Impact | Mitigation |
|------|--------|------------|
| SMTP server unreliable | High - emails not delivered | Log all email attempts, provide admin UI to resend manually (future) |
| Duplicate registrations | Medium - data integrity | Unique constraint on email, backend validation |
| Admin password compromise | High - security breach | Bcrypt hashing, HTTPS enforcement, short JWT expiry |
| Database connection pool exhaustion | Medium - service downtime | Configure reasonable pool limits, connection timeout |
| Frontend API key exposure | Low - API is backend-only | No API keys in frontend, JWT for auth only |
| Concurrent payment updates | Low - race condition | Database transaction isolation, optimistic locking optional |

---

## Success Metrics (Reiteration from Spec)

- Registration completion time: <2 minutes
- Admin update time: <30 seconds
- Email delivery time: <5 seconds
- Zero duplicate emails per participant
- 100+ participants supported
- 100% bcrypt password storage
- 0% unauthorized admin access
- Email failures don't block payment updates

---

## Next Steps

1. Run `/speckit.tasks` to generate detailed implementation tasks
2. Review and approve data model and API contracts
3. Setup local development environment (PostgreSQL, Go, Node.js)
4. Begin Phase 2 implementation starting with database and backend core
5. Iterate through task list with regular testing checkpoints

---

**Document Status**: Ready for implementation
**Approval Required**: Yes (review data model, API contracts, email template)
**Estimated Effort**: 3-5 days for solo developer (MVP scope)
